# Иерархия исключений

Все классы исключений идут из одного корня и при этом разделяются на Logic и Runtime-исключения.

То есть, существует возможность либо поймать исключения, бросаемые одной конкретной библиотекой, 
либо, например, все Runtime-исключения, вне зависимости от того, где они выброшены.

Базовые исключения:

* `Error` (interface)
    * `Logic` (наследуется от `Error` и от глобального `LogicException`)
    * `Runtime` (от `Error` и от глобального `RuntimeException`)

## Предопределённые исключения

Следующие исключения из пространства имён `axy\errors` можно использовать напрямую или для создания на их основе своих.
Все промежуточные исключения (имеющие потомков) выполнены в виде интерфейсов.
Выбросить их непосредственно нельзя, но можно использовать для отлова группы ошибок.
Все классы наследуются от `Logic` или `Runtime`.
Если не указано явно, то класс наследуется от `Logic`.

* `Forbidden` - действие запрещено
    * `ReadOnly` - попытка записи в поле только для чтения
        * [ContainerReadOnly](ContainerReadOnly.md) - неизменяемый контейнер
        * [PropertyReadOnly](PropertyReadOnly.md) - поле только для чтения
    * [Disabled](Disabled.md) - сервис отключён
    * [Pointless](Pointless.md) - бессмысленная в данном контексте операция
* [ActionNotAllowed] - действие запрещено для данного объекта
* `NotFound` - не найден элемент контейнера
    * [AdapterNotDefined]
    * [FieldNotExist] - элемент не существует
    * [ItemNotFound] (Runtime) - элемент не найден в данный момент
* `Init` - ошибка, связанная с инициализацией объекта
    * [AlreadyInited]  - попытка повторной инициализации
    * [NotInited] - доступ к неинициализированному объекту
* DependencyError - 
    * [NotInstalled]
* [InvalidConfig] - конфигурация имеет неверный формат
* [InvalidFormat] - 
* `InvalidValue` - ошибочный формат некоего значения
    * [NotValid] - не прошло валидацию
    * [TypingError] - неверный тип
* [RequiresOverride]


## Пример использования

Предлагается следующая схема.
Например, есть библиотека расположенная в пространстве `my\ns`.
Все классы исключений располагаются во вложенном пространстве `my\ns\errors`.

Определяется интерфейс `Error`, унаследованный от `axy\errors\Error` - базовое исключение библиотеки.
Все конкретные классы наследуются от `Error` и, одновременно, от `axy\errors\Logic` или `axy\errors\Runtime` (или от более конкретного класса).

Например:
```php
namespace my\ns\errors;

class InvalidMyConfig extends \axy\errors\InvalidConfig implements Error
{
}
```

При этом исключение `my\ns\errors\InvalidMyConfig` является наследником следующих классов и интерфейсов:

* `Exception`.
* `LogicException` - отловить все Logic-ошибки.
* `axy\errors\Error` - отловить все axy-ошибки.
* `axy\errors\Logic`.
* `axy\errors\InvalidConfig` - отловить все ошибочные конфиги.
* `my\ns\Error` - все ошибки библиотеки `my\ns`.

## Конструкторы

Конструктор базовых `Logic` и `Runtime` имеет следующий вид:

```plain
__constructor([mixed $message [, int $code [, Exception $previous [, mixed $thrower])
```

От стандартного конструктора отличия следующие:

* `$message` может принимать не только строку, но массив переменных для [формирования сообщения](message.md).
* `$thrower` содержит указание на того, кто выбросил исключение. Нужно для [обрезки стека](trace.md).

Конструкторы остальных классов могут содержать вместо `$message` и `$code` более конкретные аргументы.
Однако, все стандартные классы из `axy\errors` получают последними двумя аргументами `$previous` и `$thrower`.

Например, конструктор `FieldNotExists::__construct([$key [, $container [, $previous [, $thrower])`.
Получает ссылку на контейнер и ключ не найденного в нём свойства.
На их основе уже формируется сообщение.
